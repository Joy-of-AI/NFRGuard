#!/usr/bin/env python3
"""
AWS RAG Engine for Australian Banking Regulatory Documents
Updated to use Amazon OpenSearch Serverless + Bedrock Titan Embeddings
"""

import os
import json
import logging
import hashlib
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass
from pathlib import Path

from document_downloader import AustralianBankingDocumentDownloader, RegulatoryDocument
from aws_rag_engine import AWSRAGEngine, DocumentChunk, SearchResult

# Set up logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@dataclass
class RAGQuery:
    """Represents a RAG query"""
    query_text: str
    agent_type: str
    context: Dict[str, Any]
    filters: Dict[str, Any]

@dataclass
class RAGResult:
    """Represents a RAG result"""
    query: str
    relevant_documents: List[SearchResult]
    context: str
    confidence: float
    sources: List[str]

class DocumentProcessor:
    """Processes and chunks documents for vector storage"""
    
    def __init__(self, chunk_size: int = 1000, chunk_overlap: int = 200):
        self.chunk_size = chunk_size
        self.chunk_overlap = chunk_overlap
        
    def process_document(self, document: RegulatoryDocument) -> List[DocumentChunk]:
        """Process a regulatory document into chunks for vector storage"""
        chunks = self._chunk_text(document.content)
        
        document_chunks = []
        for i, chunk in enumerate(chunks):
            # Create unique ID for chunk
            chunk_id = self._generate_chunk_id(document, i)
            
            # Create metadata
            metadata = {
                "title": document.title,
                "regulator": document.regulator,
                "document_type": document.document_type,
                "sections": document.sections,
                "agent_focus": document.agent_focus,
                "relevance": document.relevance,
                "chunk_index": i,
                "total_chunks": len(chunks),
                "url": document.url
            }
            
            # Create document chunk (embedding will be generated by AWS RAG engine)
            doc_chunk = DocumentChunk(
                id=chunk_id,
                content=chunk,
                embedding=[],  # Will be generated by Bedrock
                metadata=metadata,
                source=document.source,
                chunk_index=i
            )
            
            document_chunks.append(doc_chunk)
            
        return document_chunks
    
    def _chunk_text(self, text: str) -> List[str]:
        """Split text into chunks with overlap"""
        if len(text) <= self.chunk_size:
            return [text]
        
        chunks = []
        start = 0
        
        while start < len(text):
            end = start + self.chunk_size
            
            # Try to break at sentence boundary
            if end < len(text):
                # Look for sentence endings within the last 200 characters
                sentence_end = text.rfind('.', start, end)
                if sentence_end > start + self.chunk_size - 200:
                    end = sentence_end + 1
            
            chunk = text[start:end].strip()
            if chunk:
                chunks.append(chunk)
            
            start = end - self.chunk_overlap
        
        return chunks
    
    def _generate_chunk_id(self, document: RegulatoryDocument, chunk_index: int) -> str:
        """Generate unique ID for document chunk"""
        content_hash = hashlib.md5(document.content.encode()).hexdigest()[:8]
        return f"{document.regulator}_{content_hash}_{chunk_index}"

class AustralianBankingRAG:
    """Main RAG engine for Australian banking regulations (AWS implementation)"""
    
    def __init__(self):
        self.document_downloader = AustralianBankingDocumentDownloader()
        self.aws_rag = AWSRAGEngine()
        self.processor = DocumentProcessor()
        self.initialized = False
        
        # Agent-specific configurations
        self.agent_configs = {
            "transaction_risk": {
                "focus_areas": ["fraud", "money_laundering", "transaction_monitoring"],
                "regulators": ["AUSTRAC", "APRA"],
                "document_types": ["guidelines", "regulations", "standards"]
            },
            "compliance": {
                "focus_areas": ["regulatory_compliance", "reporting", "governance"],
                "regulators": ["APRA", "ASIC", "RBA"],
                "document_types": ["prudential_standards", "guidelines", "regulations"]
            },
            "data_privacy": {
                "focus_areas": ["privacy", "data_protection", "consent"],
                "regulators": ["OAIC", "APRA"],
                "document_types": ["privacy_guidelines", "data_protection_standards"]
            },
            "customer_sentiment": {
                "focus_areas": ["customer_protection", "complaints", "service_standards"],
                "regulators": ["AFCA", "ASIC"],
                "document_types": ["customer_guidelines", "service_standards"]
            },
            "resilience": {
                "focus_areas": ["operational_resilience", "business_continuity", "risk_management"],
                "regulators": ["APRA", "RBA"],
                "document_types": ["resilience_standards", "risk_guidelines"]
            },
            "knowledge": {
                "focus_areas": ["general_knowledge", "documentation", "guidance"],
                "regulators": ["APRA", "ASIC", "AUSTRAC", "AFCA"],
                "document_types": ["all"]
            },
            "banking_assistant": {
                "focus_areas": ["general_banking", "customer_service", "operations"],
                "regulators": ["APRA", "ASIC", "AFCA"],
                "document_types": ["guidelines", "standards", "regulations"]
            }
        }
    
    def initialize(self) -> bool:
        """Initialize the RAG system"""
        try:
            logger.info("Initializing AWS RAG system...")
            
            # Check if documents are already indexed
            # For now, we'll assume documents are indexed separately
            # In production, you might want to check index status here
            
            self.initialized = True
            logger.info("AWS RAG system initialized successfully")
            return True
            
        except Exception as e:
            logger.error(f"Failed to initialize AWS RAG system: {e}")
            return False
    
    def download_and_index_documents(self) -> bool:
        """Download and index regulatory documents"""
        try:
            logger.info("Starting document download and indexing...")
            
            # Download documents
            documents = self.document_downloader.download_all_documents()
            if not documents:
                logger.warning("No documents downloaded")
                return False
            
            logger.info(f"Downloaded {len(documents)} documents")
            
            # Process documents into chunks
            all_chunks = []
            for document in documents:
                chunks = self.processor.process_document(document)
                all_chunks.extend(chunks)
            
            logger.info(f"Processed {len(all_chunks)} document chunks")
            
            # Convert to format expected by AWS RAG engine
            rag_documents = []
            for chunk in all_chunks:
                rag_doc = {
                    "id": chunk.id,
                    "content": chunk.content,
                    "metadata": chunk.metadata,
                    "source": chunk.source
                }
                rag_documents.append(rag_doc)
            
            # Add documents to AWS RAG engine
            success = self.aws_rag.add_documents(rag_documents)
            
            if success:
                logger.info("Documents indexed successfully in AWS RAG system")
                return True
            else:
                logger.error("Failed to index documents in AWS RAG system")
                return False
                
        except Exception as e:
            logger.error(f"Error downloading and indexing documents: {e}")
            return False
    
    def query(self, query_text: str, agent_type: str, context: Dict[str, Any] = None) -> RAGResult:
        """Query the RAG system"""
        try:
            if not self.initialized:
                logger.warning("RAG system not initialized, attempting to initialize...")
                if not self.initialize():
                    return RAGResult(
                        query=query_text,
                        relevant_documents=[],
                        context="RAG system not available",
                        confidence=0.0,
                        sources=[]
                    )
            
            # Build context with agent-specific configuration
            enhanced_context = self._build_agent_context(agent_type, context or {})
            
            # Query AWS RAG engine
            result = self.aws_rag.query(query_text, agent_type, enhanced_context)
            
            logger.info(f"RAG query completed for {agent_type}: {len(result.relevant_documents)} results")
            return result
            
        except Exception as e:
            logger.error(f"Error querying RAG system: {e}")
            return RAGResult(
                query=query_text,
                relevant_documents=[],
                context="Error retrieving information",
                confidence=0.0,
                sources=[]
            )
    
    def _build_agent_context(self, agent_type: str, context: Dict[str, Any]) -> Dict[str, Any]:
        """Build enhanced context for specific agent type"""
        enhanced_context = context.copy()
        
        if agent_type in self.agent_configs:
            agent_config = self.agent_configs[agent_type]
            enhanced_context.update({
                "focus_areas": agent_config["focus_areas"],
                "regulators": agent_config["regulators"],
                "document_types": agent_config["document_types"]
            })
        
        return enhanced_context
    
    def get_agent_specific_guidance(self, agent_type: str, query: str, context: Dict[str, Any] = None) -> str:
        """Get agent-specific regulatory guidance"""
        result = self.query(query, agent_type, context)
        
        if result.relevant_documents:
            guidance = f"Based on regulatory documents, here's the relevant guidance:\n\n{result.context}\n\n"
            guidance += f"Confidence: {result.confidence:.2f}\n"
            guidance += f"Sources: {', '.join(set(result.sources))}"
            return guidance
        else:
            return f"No specific regulatory guidance found for {agent_type} regarding: {query}"
    
    def update_documents(self) -> bool:
        """Update documents (re-download and re-index)"""
        try:
            logger.info("Updating documents...")
            
            # Clear existing index (optional - in production you might want incremental updates)
            # self.aws_rag.vector_store.delete_index()
            # self.aws_rag.vector_store.create_index()
            
            # Re-download and index
            return self.download_and_index_documents()
            
        except Exception as e:
            logger.error(f"Error updating documents: {e}")
            return False
    
    def get_system_status(self) -> Dict[str, Any]:
        """Get system status information"""
        return {
            "initialized": self.initialized,
            "aws_rag_available": self.aws_rag is not None,
            "document_downloader_available": self.document_downloader is not None,
            "agent_configs": list(self.agent_configs.keys())
        }

# Global RAG instance
_rag_instance = None

def get_rag_instance() -> AustralianBankingRAG:
    """Get global RAG instance"""
    global _rag_instance
    if _rag_instance is None:
        _rag_instance = AustralianBankingRAG()
    return _rag_instance

# Example usage and testing
if __name__ == "__main__":
    # Test AWS RAG system
    rag = AustralianBankingRAG()
    
    # Initialize
    if rag.initialize():
        print("✅ RAG system initialized successfully")
        
        # Test query
        result = rag.query(
            "What are the requirements for transaction monitoring?",
            "transaction_risk",
            {"regulator": "AUSTRAC"}
        )
        
        print(f"Query results: {len(result.relevant_documents)} documents found")
        print(f"Confidence: {result.confidence:.2f}")
        print(f"Context preview: {result.context[:200]}...")
        
    else:
        print("❌ Failed to initialize RAG system")
        print("Make sure AWS credentials are configured and OpenSearch endpoint is set")

